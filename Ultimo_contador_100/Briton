#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ILI9341.h>
#include <XPT2046_Touchscreen.h>
#include <EEPROM.h>

// ConfiguraciÃ³n de pines para Raspberry Pi Pico RP2040
#define TFT_CS   19   // GP19 - Chip Select TFT
#define TFT_DC   5    // GP5  - Data/Command
#define TFT_RST  13   // GP13 - Reset
#define TS_CS    0    // GP0  - Touch Screen Chip Select (TCS)
#define TFT_MOSI 11   // GP11 - Master Out Slave In
#define TFT_MISO 12   // GP12 - Master In Slave Out  
#define TFT_SCK  10   // GP10 - Serial Clock
#define TS_IRQ   2    // GP2  - Touch Interrupt Request (TIRQ)

#define ROTATION 3
#define ROTATIONs 1

// Pines UART para Pico RP2040
#define RX1_PIN  17   // GP17 - RX
#define TX1_PIN  16   // GP16 - TX

// Pin para buzzer/seÃ±al de salida
#define BUZZER_PIN 20  // GP20 para buzzer/seÃ±al

// InicializaciÃ³n de componentes usando SPI por defecto - CONFIGURADO PARA RP2040
Adafruit_ILI9341 tft = Adafruit_ILI9341(TFT_CS, TFT_DC, TFT_RST);
XPT2046_Touchscreen ts(TS_CS, TS_IRQ);

// Constantes para pantalla 2.4"
#define SCREEN_WIDTH 320
#define SCREEN_HEIGHT 240

// Paleta de colores mejorada
#define COLOR_BG          0x0000  // Negro
#define COLOR_ACCENT      0xFFE0  // Amarillo
#define COLOR_PRIMARY     0x07FF  // Cyan
#define COLOR_SECONDARY   0xF81F  // Magenta
#define COLOR_SUCCESS     0x07E0  // Verde
#define COLOR_WARNING     0xFD20  // Naranja
#define COLOR_DANGER      0xF800  // Rojo
#define COLOR_INFO        0x001F  // Azul
#define COLOR_LIGHT       0xFFFF  // Blanco
#define COLOR_DARK        0x18E3  // Gris oscuro
#define COLOR_GRAY        0xC618  // Gris medio

// EnumeraciÃ³n para pantallas
enum Screens {
  SCREEN_MAIN = 0,
  SCREEN_CALIBRATION = 1,
  SCREEN_PROCESS_MENU = 2,
  SCREEN_PROCESS_P = 3,
  SCREEN_PROCESS_G = 4,
  SCREEN_CONFIG_P = 5,
  SCREEN_CONFIG_G = 6,
  SCREEN_QUANTITY_P = 8,
  SCREEN_QUANTITY_G = 9
};

// Estructura para botones
typedef struct {
  int16_t x, y, w, h;
  uint16_t color;
  const char* text;
  uint16_t textColor;
  uint8_t textSize;
} Button;

// Variables de control de pantallas
uint8_t currentScreen = SCREEN_CALIBRATION;
bool screenOn = true;
bool needRedraw = true;

// Variables para contadores
int counterP = 0;
int counterG = 0;
bool counterP_active = false;
bool counterG_active = false;
bool counterP_paused = false;
bool counterG_paused = false;

// Variables para lÃ­mites de conteo
int targetP = 0;
int targetG = 0;
bool infiniteP = true;
bool infiniteG = true;
bool modeSelectedP = false;
bool modeSelectedG = false;
const int HIDDEN_LIMIT = 1000;

// Variables para detecciÃ³n de seÃ±al y botella
unsigned long lastDebounceTime = 0;
const unsigned long debounceDelay = 50;
bool showingBottleAlert = false;
bool alertDismissed = false;

// Variables para timeout de menÃºs
unsigned long menuTimeout = 0;
const unsigned long timeoutDelay = 5000;

// Variables de calibraciÃ³n
bool calibrationComplete = false;
TS_Point calibrationPoints[6];
int calibrationStep = 0;
bool waitingForCalibrationTouch = false;

// Variables para debounce del touch
unsigned long lastTouchTime = 0;
const unsigned long touchDebounceDelay = 300;

// Variables para animaciones
unsigned long animationStartTime = 0;
const unsigned long animationDuration = 300;
bool animating = false;
uint8_t animationProgress = 0;
unsigned long lastAnimationTime = 0;
const unsigned long animationInterval = 50;

// Variables para comunicaciÃ³n UART
String receivedCommand = "";
bool commandComplete = false;

// FunciÃ³n para activar buzzer/seÃ±al por GP20
void activateBuzzer() {
  digitalWrite(BUZZER_PIN, HIGH);
  delay(100);  // Mantener seÃ±al por 100ms
  digitalWrite(BUZZER_PIN, LOW);
  Serial.println(F("Buzzer activado en GP20"));
}

// FunciÃ³n para dibujar un botÃ³n redondeado
void drawButton(Button btn) {
  // Dibujar fondo con esquinas redondeadas
  tft.fillRoundRect(btn.x, btn.y, btn.w, btn.h, 8, btn.color);
  
  // AÃ±adir efecto de borde para dar profundidad
  uint16_t highlightColor = (btn.color == COLOR_DANGER) ? COLOR_DANGER :
                            ((btn.color == COLOR_SUCCESS) ? 0x0700 : 0x0000);
  
  // Borde superior e izquierdo mÃ¡s claro (highlight)
  tft.drawRoundRect(btn.x, btn.y, btn.w, btn.h, 8, btn.color + highlightColor);
  
  // Texto centrado
  int16_t textWidth = strlen(btn.text) * 6 * btn.textSize;
  int16_t textX = btn.x + (btn.w - textWidth) / 2;
  int16_t textY = btn.y + (btn.h - 8 * btn.textSize) / 2 + 4;
  
  tft.setTextColor(btn.textColor);
  tft.setTextSize(btn.textSize);
  tft.setCursor(textX, textY);
  tft.print(btn.text);
}

// Efecto visual al presionar un botÃ³n
void buttonPressEffect(Button btn) {
  // Guardar color original
  uint16_t originalColor = btn.color;
  
  // Cambiar a color mÃ¡s oscuro
  btn.color = (btn.color == COLOR_LIGHT) ? COLOR_GRAY :
              ((btn.color == COLOR_SUCCESS) ? 0x0500 :
              ((btn.color == COLOR_DANGER) ? 0x8000 :
              ((btn.color == COLOR_INFO) ? 0x0010 : btn.color - 0x1082)));
  
  // Redibujar botÃ³n
  drawButton(btn);
  delay(100);
  
  // Restaurar color original
  btn.color = originalColor;
  drawButton(btn);
}

void setup() {
  // UART0 para debug/monitor serie
  Serial.begin(57600);
  
  // UART1 para comunicaciÃ³n con dispositivo externo (Pico RP2040)
  Serial1.setTX(TX1_PIN);
  Serial1.setRX(RX1_PIN);
  Serial1.begin(57600);
  
  // ConfiguraciÃ³n de pines SPI personalizados - CONFIGURADO PARA RP2040
  SPI.setSCK(TFT_SCK);   // GP10 - Configurar pin SCK
  SPI.setMOSI(TFT_MOSI); // GP11 - Configurar pin MOSI
  SPI.setMISO(TFT_MISO); // GP12 - Configurar pin MISO
  SPI.begin();           // Inicializar SPI despuÃ©s de configurar pines
  
  // ConfiguraciÃ³n de pines
  pinMode(TS_CS, OUTPUT);     // GP0 - TCS
  digitalWrite(TS_CS, HIGH);
  pinMode(TFT_CS, OUTPUT);    // GP19 - CS
  digitalWrite(TFT_CS, HIGH);
  pinMode(TS_IRQ, INPUT_PULLUP); // GP2 - TIRQ con pull-up
  
  // Configurar pin GP20 como salida para buzzer
  pinMode(BUZZER_PIN, OUTPUT);
  digitalWrite(BUZZER_PIN, LOW);
  
  // InicializaciÃ³n de pantalla y touch
  tft.begin();
  ts.begin();
  ts.setRotation(ROTATIONs);
  tft.setRotation(ROTATION);
  
  // Inicializar EEPROM para Pico RP2040
  EEPROM.begin(512);
  
  // Efecto de inicio
  startupAnimation();
  
  // Cargar contadores guardados
  EEPROM.get(0, counterP);
  EEPROM.get(4, counterG);
  
  // Iniciar calibraciÃ³n de pantalla
  startCalibration();
  
  Serial.println(F("Sistema iniciado en Raspberry Pi Pico RP2040"));
  Serial.println(F("ConfiguraciÃ³n de pines actualizada:"));
  Serial.println(F("TCS=GP0, TIRQ=GP2, DC=GP5, CLK=GP10"));
  Serial.println(F("MOSI=GP11, MISO=GP12, RESET=GP13"));
  Serial.println(F("TX=GP16, RX=GP17, CS=GP19, BUZZER=GP20"));
  Serial.println(F("UART1 configurado en pines TX(GP16) y RX(GP17) a 57600 baudios"));
}

// AnimaciÃ³n de inicio
void startupAnimation() {
  // Fondo negro
  tft.fillScreen(COLOR_BG);
  
  // Dibujar logo o nombre del sistema
  tft.setTextColor(COLOR_PRIMARY);
  tft.setTextSize(2);
  
  // AnimaciÃ³n de apariciÃ³n de texto
  for (int i = 0; i <= 100; i += 5) {
    int alpha = i * 255 / 100;
    uint16_t color = ((alpha >> 3) << 11) | ((alpha >> 2) << 5) | (alpha >> 3);
    
    tft.fillScreen(COLOR_BG);
    tft.setTextColor(color);
    tft.setCursor(60, 100);
    tft.println(F("SISTEMA DE CONTROL"));
    tft.setCursor(100, 130);
    tft.println(F("INDUSTRIAL"));
    tft.setCursor(80, 160);
    tft.setTextSize(1);
    tft.println(F("Raspberry Pi Pico RP2040"));
    
    // Barra de progreso
    tft.drawRect(60, 180, 200, 20, COLOR_LIGHT);
    tft.fillRect(62, 182, i * 196 / 100, 16, COLOR_PRIMARY);
    
    delay(20);
  }
  
  delay(500);
}

void startCalibration() {
  currentScreen = SCREEN_CALIBRATION;
  calibrationComplete = false;
  calibrationStep = 0;
  waitingForCalibrationTouch = false;
  
  tft.fillScreen(COLOR_BG);
  tft.setTextColor(COLOR_LIGHT);
  tft.setTextSize(1);
  tft.setCursor(20, 30);
  tft.println(F("CALIBRACION DE PANTALLA"));
  
  tft.setCursor(20, 50);
  tft.println(F("Toque el centro de cada"));
  tft.setCursor(20, 65);
  tft.println(F("circulo que aparezca"));
  tft.setCursor(20, 80);
  tft.println(F("6 puntos para mejor precision"));
  
  delay(2000);
  showCalibrationPoint();
}

void showCalibrationPoint() {
  tft.fillScreen(COLOR_BG);
  
  // Inicializar con valores por defecto para evitar advertencias
  int x = 30, y = 30;
  
  switch(calibrationStep) {
    case 0: x = 30; y = 30; break;
    case 1: x = SCREEN_WIDTH - 30; y = 30; break;
    case 2: x = SCREEN_WIDTH/2; y = SCREEN_HEIGHT/2; break;
    case 3: x = 30; y = SCREEN_HEIGHT - 30; break;
    case 4: x = SCREEN_WIDTH - 30; y = SCREEN_HEIGHT - 30; break;
    case 5: x = SCREEN_WIDTH/2; y = 30; break;
    default: 
      // Caso de seguridad si calibrationStep estÃ¡ fuera del rango esperado
      x = SCREEN_WIDTH/2; 
      y = SCREEN_HEIGHT/2;
      Serial.print(F("Advertencia: calibrationStep fuera de rango: "));
      Serial.println(calibrationStep);
      break;
  }
  
  // AnimaciÃ³n de pulso para el punto de calibraciÃ³n
  for (int i = 0; i < 3; i++) {
    for (int r = 5; r <= 15; r++) {
      tft.drawCircle(x, y, r, COLOR_PRIMARY);
      delay(10);
    }
    for (int r = 15; r >= 5; r--) {
      tft.fillScreen(COLOR_BG);
      tft.drawCircle(x, y, r, COLOR_PRIMARY);
      tft.fillCircle(x, y, 5, COLOR_ACCENT);
      delay(10);
    }
  }
  
  // Dibujo final del punto
  tft.fillScreen(COLOR_BG);
  tft.drawLine(x-10, y, x+10, y, COLOR_DANGER);
  tft.drawLine(x, y-10, x, y+10, COLOR_DANGER);
  tft.drawCircle(x, y, 6, COLOR_DANGER);
  tft.drawCircle(x, y, 10, COLOR_ACCENT);
  
  tft.setTextColor(COLOR_LIGHT);
  tft.setTextSize(1);
  tft.setCursor(10, 10);
  tft.print(F("Punto "));
  tft.print(calibrationStep + 1);
  tft.print(F(" de 6"));
  
  waitingForCalibrationTouch = true;
  Serial.print(F("Esperando toque para punto "));
  Serial.println(calibrationStep + 1);
}

void handleCalibrationTouch() {
  if (!waitingForCalibrationTouch || currentScreen != SCREEN_CALIBRATION) {
    return;
  }
  
  if (!ts.touched()) return;
  
  // Debounce mejorado para calibraciÃ³n
  if (millis() - lastTouchTime < 500) {
    return;
  }
  
  lastTouchTime = millis();
  waitingForCalibrationTouch = false;
  
  TS_Point p = ts.getPoint();
  calibrationPoints[calibrationStep] = p;
  
  Serial.print(F("Punto de calibraciÃ³n "));
  Serial.print(calibrationStep + 1);
  Serial.print(F(": X="));
  Serial.print(p.x);
  Serial.print(F(", Y="));
  Serial.println(p.y);
  
  calibrationStep++;
  
  if (calibrationStep >= 6) {
    completeCalibration();
  } else {
    delay(500);
    showCalibrationPoint();
  }
}

void completeCalibration() {
  calibrationComplete = true;
  waitingForCalibrationTouch = false;
  
  // AnimaciÃ³n de completado
  for (int i = 0; i <= 100; i += 5) {
    tft.fillScreen(COLOR_BG);
    
    // CÃ­rculo que se completa
    int angle = i * 360 / 100;
    for (int j = 0; j < angle; j += 5) {
      float rads = j * PI / 180;
      int x = SCREEN_WIDTH/2 + cos(rads) * 50;
      int y = SCREEN_HEIGHT/2 + sin(rads) * 50;
      tft.fillCircle(x, y, 5, COLOR_SUCCESS);
    }
    
    delay(10);
  }
  
  tft.fillScreen(COLOR_SUCCESS);
  tft.setTextColor(COLOR_BG);
  tft.setTextSize(1);
  tft.setCursor(30, 60);
  tft.println(F("CALIBRACION COMPLETA"));
  tft.setCursor(20, 80);
  tft.println(F("6 puntos calibrados exitosamente"));
  
  delay(1500);
  currentScreen = SCREEN_MAIN;
  needRedraw = true;
  Serial.println(F("CalibraciÃ³n completada con 6 puntos - Sistema listo"));
}

void drawMainMenu() {
  if (!screenOn) return;
  
  tft.fillScreen(COLOR_BG);
  
  // TÃ­tulo con gradiente
  for (int i = 0; i < 20; i++) {
    uint16_t gradientColor = COLOR_ACCENT - (i * 5);
    tft.drawFastHLine(60, 10 + i, 200, gradientColor);
  }
  
  tft.setTextColor(COLOR_BG);
  tft.setTextSize(1);
  tft.setCursor(90, 15);
  tft.println(F("MENU PRINCIPAL"));
  
  // Botones con efecto 3D
  Button btnEncender = {60, 40, 200, 45, COLOR_SUCCESS, "INICIAR", COLOR_BG, 1};
  Button btnApagar = {60, 100, 200, 45, COLOR_DANGER, "APAGAR", COLOR_LIGHT, 1};
  
  drawButton(btnEncender);
  drawButton(btnApagar);
  
  // InformaciÃ³n del sistema
  tft.setTextColor(COLOR_GRAY);
  tft.setTextSize(1);
  tft.setCursor(10, 200);
  tft.print(F("Pico RP2040 v2.0"));
  
  tft.setCursor(10, 220);
  tft.print(F("Pines actualizados"));
  
  // Fecha y hora (simuladas)
  tft.setCursor(230, 220);
  tft.print(F("19/06/2025"));
  
  currentScreen = SCREEN_MAIN;
  needRedraw = false;
}

void turnOffScreen() {
  // AnimaciÃ³n de apagado
  for (int i = 255; i >= 0; i -= 15) {
    // Simular fade-out reduciendo brillo
    tft.fillScreen(((i >> 3) << 11) | ((i >> 2) << 5) | (i >> 3));
    delay(10);
  }
  
  screenOn = false;
  tft.fillScreen(COLOR_BG);
  
  // Enviar comando de pausa por UART1
  Serial1.println("pausa");
  
  Serial.println(F("Pantalla apagada y seÃ±al de pausa enviada por UART1"));
}

void turnOnScreen() {
  screenOn = true;
  
  // AnimaciÃ³n de encendido
  for (int i = 0; i <= 255; i += 15) {
    // Simular fade-in aumentando brillo
    tft.fillScreen(((i >> 3) << 11) | ((i >> 2) << 5) | (i >> 3));
    delay(10);
  }
  
  needRedraw = true;
  Serial.println(F("Pantalla encendida"));
}

void drawProcessMenu() {
  if (!screenOn) return;
  
  tft.fillScreen(COLOR_BG);
  
  // TÃ­tulo con borde
  tft.fillRoundRect(20, 5, 280, 25, 5, COLOR_DARK);
  tft.drawRoundRect(20, 5, 280, 25, 5, COLOR_LIGHT);
  
  tft.setTextColor(COLOR_LIGHT);
  tft.setTextSize(1);
  tft.setCursor(70, 12);
  tft.println(F("SELECCIONAR PROCESO"));
  
  // Botones con iconos
  Button btnProcesoP = {60, 40, 200, 45, COLOR_PRIMARY, "PROCESO P", COLOR_BG, 1};
  Button btnProcesoG = {60, 100, 200, 45, COLOR_SECONDARY, "PROCESO G", COLOR_BG, 1};
  Button btnRegresar = {60, 160, 200, 45, COLOR_DANGER, "REGRESAR", COLOR_LIGHT, 1};
  
  drawButton(btnProcesoP);
  drawButton(btnProcesoG);
  drawButton(btnRegresar);
  
  // Iconos para los procesos
  // Proceso P - Icono circular
  tft.fillCircle(80, 62, 10, COLOR_BG);
  tft.drawCircle(80, 62, 10, COLOR_LIGHT);
  tft.fillTriangle(76, 62, 84, 58, 84, 66, COLOR_LIGHT);
  
  // Proceso G - Icono cuadrado
  tft.fillRect(70, 122, 20, 20, COLOR_BG);
  tft.drawRect(70, 122, 20, 20, COLOR_LIGHT);
  tft.fillTriangle(75, 132, 85, 127, 85, 137, COLOR_LIGHT);
  
  currentScreen = SCREEN_PROCESS_MENU;
  needRedraw = false;
}

void drawProcessCounter(bool isProcessP) {
  if (!screenOn) return;
  
  tft.fillScreen(COLOR_BG);
  
  // TÃ­tulo con color segÃºn proceso
  uint16_t processColor = isProcessP ? COLOR_PRIMARY : COLOR_SECONDARY;
  tft.fillRoundRect(20, 5, 280, 25, 5, processColor);
  
  tft.setTextColor(COLOR_BG);
  tft.setTextSize(1);
  tft.setCursor(isProcessP ? 120 : 120, 12);
  tft.println(isProcessP ? F("PROCESO P") : F("PROCESO G"));
  
  // Panel de contador con borde
  tft.fillRoundRect(20, 35, 280, 50, 5, COLOR_DARK);
  tft.drawRoundRect(20, 35, 280, 50, 5, COLOR_LIGHT);
  
  tft.setTextSize(2);
  tft.setTextColor(COLOR_LIGHT);
  tft.setCursor(30, 45);
  tft.print(F("Contador: "));
  
  // Valor del contador con efecto de sombra
  tft.setTextColor(COLOR_DARK);
  tft.setCursor(171, 46);
  tft.print(isProcessP ? counterP : counterG);
  tft.setTextColor(COLOR_ACCENT);
  tft.setCursor(170, 45);
  tft.print(isProcessP ? counterP : counterG);
  
  // Panel de informaciÃ³n
  tft.fillRoundRect(20, 90, 280, 50, 5, COLOR_DARK);
  
  tft.setTextSize(1);
  tft.setCursor(30, 100);
  
  // Mostrar modo
  bool modeSelected = isProcessP ? modeSelectedP : modeSelectedG;
  bool infinite = isProcessP ? infiniteP : infiniteG;
  int target = isProcessP ? targetP : targetG;
  int counter = isProcessP ? counterP : counterG;
  
  if (!modeSelected) {
    tft.setTextColor(COLOR_WARNING);
    tft.println(F("Modo: NO SELECCIONADO"));
  } else if (infinite) {
    tft.setTextColor(COLOR_SUCCESS);
    tft.println(F("Modo: CONTINUO"));
  } else {
    tft.setTextColor(COLOR_ACCENT);
    tft.print(F("Objetivo: "));
    tft.print(target);
    tft.print(F(" (Faltan: "));
    tft.print(max(0, target - counter));
    tft.println(F(")"));
  }
  
  // Mostrar estado
  bool active = isProcessP ? counterP_active : counterG_active;
  bool paused = isProcessP ? counterP_paused : counterG_paused;
  
  tft.setCursor(30, 115);
  if (active && !paused && modeSelected) {
    tft.setTextColor(COLOR_SUCCESS);
    tft.println(F("Estado: ACTIVO - CONTANDO"));
    
    // Indicador visual de actividad
    static int pulseSize = 0;
    static bool growing = true;
    
    if (growing) {
      pulseSize++;
      if (pulseSize >= 5) growing = false;
    } else {
      pulseSize--;
      if (pulseSize <= 0) growing = true;
    }
    
    tft.fillCircle(250, 115, 5 + pulseSize, COLOR_SUCCESS);
  } else if (paused) {
    tft.setTextColor(COLOR_DANGER);
    tft.println(F("Estado: PAUSADO"));
    
    // Icono de pausa
    tft.fillRect(245, 110, 5, 10, COLOR_DANGER);
    tft.fillRect(255, 110, 5, 10, COLOR_DANGER);
  } else {
    tft.setTextColor(COLOR_WARNING);
    tft.println(F("Estado: DETENIDO"));
    
    // Icono de stop
    tft.fillRect(245, 110, 15, 10, COLOR_WARNING);
  }
  
  // Botones intercambiados (mantener funciones)
  Button btnPausar = {20, 150, 130, 35, COLOR_SUCCESS, "PAUSAR", COLOR_BG, 1};
  Button btnConfigurar = {170, 150, 130, 35, COLOR_WARNING, "CONFIGURAR", COLOR_BG, 1};
  Button btnRegresar = {60, 195, 200, 35, COLOR_DANGER, "REGRESAR", COLOR_LIGHT, 1};
  drawButton(btnPausar);
  drawButton(btnConfigurar);
  drawButton(btnRegresar);
  
  currentScreen = isProcessP ? SCREEN_PROCESS_P : SCREEN_PROCESS_G;
  needRedraw = false;
}

void drawBottleAlert() {
  if (!screenOn) return;
  
  tft.fillRect(40, 60, 240, 120, COLOR_DARK);
  
  // AnimaciÃ³n de apariciÃ³n de alerta
  for (int i = 0; i <= 240; i += 10) {
    tft.fillRoundRect(40 + (240-i)/2, 60, i, 120, 10, COLOR_DANGER);
    delay(10);
  }
  
  tft.drawRoundRect(38, 58, 244, 124, 10, COLOR_LIGHT);
  
  // Icono de advertencia
  tft.fillTriangle(160, 75, 140, 105, 180, 105, COLOR_ACCENT);
  tft.fillRect(158, 85, 4, 12, COLOR_BG);
  tft.fillRect(158, 100, 4, 4, COLOR_BG);
  
  tft.setTextColor(COLOR_LIGHT);
  tft.setTextSize(1);
  tft.setCursor(80, 115);
  tft.println(F("No se Detecta Bote"));
  tft.setCursor(70, 135);
  tft.println(F("Verifique el suministro"));
  
  // BotÃ³n OK con efecto 3D
  Button btnOK = {130, 155, 60, 25, COLOR_SUCCESS, "OK", COLOR_BG, 1};
  drawButton(btnOK);
  
  showingBottleAlert = true;
  Serial.println(F("Mostrando alerta: No se detecta bote"));
}

void dismissBottleAlert() {
  showingBottleAlert = false;
  alertDismissed = true;
  
  // AnimaciÃ³n de desapariciÃ³n
  for (int i = 240; i >= 0; i -= 10) {
    tft.fillRoundRect(40 + (240-i)/2, 60, i, 120, 10, COLOR_BG);
    delay(5);
  }
  
  needRedraw = true;
  Serial.println(F("Alerta de bote dismissada"));
}

void drawProcessConfig(bool isProcessP) {
  if (!screenOn) return;
  
  tft.fillScreen(COLOR_BG);
  
  // TÃ­tulo con color segÃºn proceso
  uint16_t processColor = isProcessP ? COLOR_PRIMARY : COLOR_SECONDARY;
  tft.fillRoundRect(20, 5, 280, 25, 5, processColor);
  
  tft.setTextColor(COLOR_BG);
  tft.setTextSize(1);
  tft.setCursor(isProcessP ? 60 : 60, 12);
  tft.println(isProcessP ? F("CONFIGURAR PROCESO P") : F("CONFIGURAR PROCESO G"));
  
  // Panel de instrucciones
  tft.fillRoundRect(20, 35, 280, 25, 5, COLOR_DARK);
  
  tft.setTextColor(COLOR_LIGHT);
  tft.setCursor(40, 42);
  tft.println(F("Seleccione el modo de operacion:"));
  
  // Botones con iconos
  Button btnCantidad = {60, 70, 200, 45, COLOR_ACCENT, "INGRESAR CANTIDAD", COLOR_BG, 1};
  Button btnSinFin = {60, 130, 200, 45, COLOR_SUCCESS, "CONTINUO", COLOR_BG, 1};
  
  drawButton(btnCantidad);
  drawButton(btnSinFin);
  
  // Iconos para los modos
  // Icono de cantidad
  tft.drawRect(75, 82, 15, 20, COLOR_BG);
  tft.drawLine(80, 75, 85, 82, COLOR_BG);
  tft.drawLine(80, 75, 75, 82, COLOR_BG);
  
  // Icono de continuo (infinito)
  tft.drawCircle(75, 142, 7, COLOR_BG);
  tft.drawCircle(90, 142, 7, COLOR_BG);
  
  currentScreen = isProcessP ? SCREEN_CONFIG_P : SCREEN_CONFIG_G;
  menuTimeout = millis();
  needRedraw = false;
}

void drawQuantityMenu(bool isProcessP) {
  if (!screenOn) return;
  
  tft.fillScreen(COLOR_BG);
  
  // TÃ­tulo con color segÃºn proceso
  uint16_t processColor = isProcessP ? COLOR_PRIMARY : COLOR_SECONDARY;
  tft.fillRoundRect(20, 5, 280, 25, 5, processColor);
  
  tft.setTextColor(COLOR_BG);
  tft.setTextSize(1);
  tft.setCursor(20, 12);
  tft.println(isProcessP ? F("SELECCIONAR CANTIDAD - PROCESO P") : F("SELECCIONAR CANTIDAD - PROCESO G"));
  
  // Panel de instrucciones
  tft.fillRoundRect(20, 35, 280, 25, 5, COLOR_DARK);
  
  tft.setTextColor(COLOR_LIGHT);
  tft.setCursor(60, 42);
  tft.println(F("Seleccione la cantidad objetivo:"));
  
  // Solo mostrar el botÃ³n de 100
  Button btn100 = {60, 125, 200, 45, COLOR_INFO, "100", COLOR_LIGHT, 2};
  drawButton(btn100);
  
  currentScreen = isProcessP ? SCREEN_QUANTITY_P : SCREEN_QUANTITY_G;
  needRedraw = false;
}

void selectQuantity(int quantity, bool isProcessP) {
  if (!screenOn) return;
  
  // AnimaciÃ³n de selecciÃ³n
  for (int i = 0; i < 3; i++) {
    tft.fillRoundRect(60, 210, 200, 25, 5, COLOR_SUCCESS);
    tft.setTextColor(COLOR_BG);
    tft.setTextSize(1);
    tft.setCursor(80, 218);
    tft.print(F("CANTIDAD SELECCIONADA: "));
    tft.print(quantity);
    delay(200);
    
    tft.fillRoundRect(60, 210, 200, 25, 5, COLOR_BG);
    delay(100);
  }
  
  tft.fillRoundRect(60, 210, 200, 25, 5, COLOR_SUCCESS);
  tft.setTextColor(COLOR_BG);
  tft.setTextSize(1);
  tft.setCursor(80, 218);
  tft.print(F("CANTIDAD SELECCIONADA: "));
  tft.print(quantity);
  
  delay(1000);
  
  if (isProcessP) {
    targetP = quantity;
    infiniteP = false;
    modeSelectedP = true;
    Serial1.println("CMD:2");
    Serial.print(F("Proceso P configurado con objetivo: "));
    Serial.println(targetP);
    startProcessP();
    needRedraw = true;
    currentScreen = SCREEN_PROCESS_P;
  } else {
    targetG = quantity;
    infiniteG = false;
    modeSelectedG = true;
    Serial1.println("CMD:4");
    Serial.print(F("Proceso G configurado con objetivo: "));
    Serial.println(targetG);
    startProcessG();
    needRedraw = true;
    currentScreen = SCREEN_PROCESS_G;
  }
}

void checkTouch() {
  if (!calibrationComplete) {
    handleCalibrationTouch();
    return;
  }
  
  // Si la pantalla estÃ¡ apagada, cualquier toque la enciende
  if (!screenOn && ts.touched()) {
    turnOnScreen();
    delay(300);
    return;
  }
  
  // Debounce del touch
  if (millis() - lastTouchTime < touchDebounceDelay) {
    return;
  }
  
  if (!ts.touched()) return;
  
  lastTouchTime = millis();
  
  TS_Point p = ts.getPoint();
  
  // Mapeo mejorado para rotaciones 3 y 1
  int16_t x = map(p.x, 300, 3800, SCREEN_WIDTH, 0);
  int16_t y = map(p.y, 200, 3800, 0, SCREEN_HEIGHT);
  
  Serial.print(F("Touch detectado en X: "));
  Serial.print(x);
  Serial.print(F(", Y: "));
  Serial.print(y);
  Serial.print(F(" - Pantalla: "));
  Serial.println(currentScreen);
  
  if (showingBottleAlert) {
    if (x >= 130 && x <= 190 && y >= 155 && y <= 180) {
      dismissBottleAlert();
    }
    return;
  }
  
  switch (currentScreen) {
    case SCREEN_MAIN:
      handleMainMenuTouch(x, y);
      break;
    case SCREEN_PROCESS_MENU:
      handleProcessMenuTouch(x, y);
      break;
    case SCREEN_PROCESS_P:
      handleProcessPCounterTouch(x, y);
      break;
    case SCREEN_PROCESS_G:
      handleProcessGCounterTouch(x, y);
      break;
    case SCREEN_CONFIG_P:
      handleProcessPConfigTouch(x, y);
      break;
    case SCREEN_CONFIG_G:
      handleProcessGConfigTouch(x, y);
      break;
    case SCREEN_QUANTITY_P:
      handleQuantityMenuTouch(x, y, true);
      break;
    case SCREEN_QUANTITY_G:
      handleQuantityMenuTouch(x, y, false);
      break;
  }
}

void handleMainMenuTouch(int16_t x, int16_t y) {
  // BotÃ³n Iniciar
  if (y >= 40 && y <= 85 && x >= 60 && x <= 260) {
    Button btnEncender = {60, 40, 200, 45, COLOR_SUCCESS, "INICIAR", COLOR_BG, 1};
    buttonPressEffect(btnEncender);
    
    Serial.println(F("BotÃ³n Iniciar presionado"));
    currentScreen = SCREEN_PROCESS_MENU;
    needRedraw = true;
  }
  // BotÃ³n Apagar
  else if (y >= 100 && y <= 145 && x >= 60 && x <= 260) {
    Button btnApagar = {60, 100, 200, 45, COLOR_DANGER, "APAGAR", COLOR_LIGHT, 1};
    buttonPressEffect(btnApagar);
    
    Serial.println(F("BotÃ³n Apagar presionado"));
    turnOffScreen();
  }
}

void handleProcessMenuTouch(int16_t x, int16_t y) {
  // BotÃ³n Proceso P
  if (y >= 40 && y <= 85 && x >= 60 && x <= 260) {
    Button btnProcesoP = {60, 40, 200, 45, COLOR_PRIMARY, "PROCESO P", COLOR_BG, 1};
    buttonPressEffect(btnProcesoP);
    
    Serial.println(F("Proceso P seleccionado"));
    currentScreen = SCREEN_PROCESS_P;
    needRedraw = true;
  }
  // BotÃ³n Proceso G
  else if (y >= 100 && y <= 145 && x >= 60 && x <= 260) {
    Button btnProcesoG = {60, 100, 200, 45, COLOR_SECONDARY, "PROCESO G", COLOR_BG, 1};
    buttonPressEffect(btnProcesoG);
    
    Serial.println(F("Proceso G seleccionado"));
    currentScreen = SCREEN_PROCESS_G;
    needRedraw = true;
  }
  // BotÃ³n Regresar
  else if (y >= 160 && y <= 205 && x >= 60 && x <= 260) {
    Button btnRegresar = {60, 160, 200, 45, COLOR_DANGER, "REGRESAR", COLOR_LIGHT, 1};
    buttonPressEffect(btnRegresar);
    
    Serial.println(F("Regresando al menÃº principal"));
    currentScreen = SCREEN_MAIN;
    needRedraw = true;
  }
}

void handleProcessPConfigTouch(int16_t x, int16_t y) {
  menuTimeout = 0;
  
  // BotÃ³n Ingresar Cantidad
  if (y >= 70 && y <= 115 && x >= 60 && x <= 260) {
    Button btnCantidad = {60, 70, 200, 45, COLOR_ACCENT, "INGRESAR CANTIDAD", COLOR_BG, 1};
    buttonPressEffect(btnCantidad);
    
    Serial.println(F("Proceso P: Abriendo menÃº de cantidad"));
    currentScreen = SCREEN_QUANTITY_P;
    needRedraw = true;
  }
  // BotÃ³n Continuo
  else if (y >= 130 && y <= 175 && x >= 60 && x <= 260) {
    Button btnSinFin = {60, 130, 200, 45, COLOR_SUCCESS, "CONTINUO", COLOR_BG, 1};
    buttonPressEffect(btnSinFin);
    
    Serial.println(F("Proceso P: Modo continuo seleccionado"));
    Serial1.println("CMD:1");
    infiniteP = true;
    targetP = HIDDEN_LIMIT;
    modeSelectedP = true;
    startProcessP();
    currentScreen = SCREEN_PROCESS_P;
    needRedraw = true;
  }
}

void handleProcessGConfigTouch(int16_t x, int16_t y) {
  menuTimeout = 0;
  
  // BotÃ³n Ingresar Cantidad
  if (y >= 70 && y <= 115 && x >= 60 && x <= 260) {
    Button btnCantidad = {60, 70, 200, 45, COLOR_ACCENT, "INGRESAR CANTIDAD", COLOR_BG, 1};
    buttonPressEffect(btnCantidad);
    
    Serial.println(F("Proceso G: Abriendo menÃº de cantidad"));
    currentScreen = SCREEN_QUANTITY_G;
    needRedraw = true;
  }
  // BotÃ³n Continuo
  else if (y >= 130 && y <= 175 && x >= 60 && x <= 260) {
    Button btnSinFin = {60, 130, 200, 45, COLOR_SUCCESS, "CONTINUO", COLOR_BG, 1};
    buttonPressEffect(btnSinFin);
    
    Serial.println(F("Proceso G: Modo continuo seleccionado"));
    Serial1.println("CMD:3");
    infiniteG = true;
    targetG = HIDDEN_LIMIT;
    modeSelectedG = true;
    startProcessG();
    currentScreen = SCREEN_PROCESS_G;
    needRedraw = true;
  }
}

void handleQuantityMenuTouch(int16_t x, int16_t y, bool isProcessP) {
  // Solo botÃ³n 100
  if (y >= 125 && y <= 170 && x >= 60 && x <= 260) {
    Button btn100 = {60, 125, 200, 45, COLOR_INFO, "100", COLOR_LIGHT, 2};
    buttonPressEffect(btn100);
    
    Serial.println(F("Cantidad 100 seleccionada"));
    selectQuantity(100, isProcessP);
  }
}

void handleProcessPCounterTouch(int16_t x, int16_t y) {
  // BotÃ³n "PAUSAR" (izquierda) - funciÃ³n de configurar
  if (y >= 150 && y <= 185 && x >= 20 && x <= 150) {
    Button btnPausar = {20, 150, 130, 35, COLOR_SUCCESS, "PAUSAR", COLOR_BG, 1};
    buttonPressEffect(btnPausar);
    
    Serial.println(F("Configurando Proceso P"));
    currentScreen = SCREEN_CONFIG_P;
    needRedraw = true;
  }
  // BotÃ³n "CONFIGURAR" (derecha) - funciÃ³n de pausar/reanudar
  else if (y >= 150 && y <= 185 && x >= 170 && x <= 300) {
    Button btnConfigurar = {170, 150, 130, 35, COLOR_WARNING, "CONFIGURAR", COLOR_BG, 1};
    buttonPressEffect(btnConfigurar);
    
    Serial.println(F("Pausar/Reanudar Proceso P"));
    
    if (counterP_paused) {
      Serial1.println("despausa");
      counterP_paused = false;
      counterP_active = true;
      Serial.println(F("Proceso P reanudado - Comando 'despausa' enviado"));
    } else {
      Serial1.println("pausa");
      pauseProcessP();
      Serial.println(F("Proceso P pausado - Comando 'pausa' enviado"));
    }
    needRedraw = true;
  }
  // BotÃ³n Regresar
  else if (y >= 195 && y <= 230 && x >= 60 && x <= 260) {
    Button btnRegresar = {60, 195, 200, 35, COLOR_DANGER, "REGRESAR", COLOR_LIGHT, 1};
    buttonPressEffect(btnRegresar);
    
    Serial.println(F("Regresando al menÃº de procesos"));
    currentScreen = SCREEN_PROCESS_MENU;
    needRedraw = true;
  }
}

void handleProcessGCounterTouch(int16_t x, int16_t y) {
  // BotÃ³n "PAUSAR" (izquierda) - funciÃ³n de configurar
  if (y >= 150 && y <= 185 && x >= 20 && x <= 150) {
    Button btnPausar = {20, 150, 130, 35, COLOR_SUCCESS, "PAUSAR", COLOR_BG, 1};
    buttonPressEffect(btnPausar);
    
    Serial.println(F("Configurando Proceso G"));
    currentScreen = SCREEN_CONFIG_G;
    needRedraw = true;
  }
  // BotÃ³n "CONFIGURAR" (derecha) - funciÃ³n de pausar/reanudar
  else if (y >= 150 && y <= 185 && x >= 170 && x <= 300) {
    Button btnConfigurar = {170, 150, 130, 35, COLOR_WARNING, "CONFIGURAR", COLOR_BG, 1};
    buttonPressEffect(btnConfigurar);
    
    Serial.println(F("Pausar/Reanudar Proceso G"));
    
    if (counterG_paused) {
      Serial1.println("despausa");
      counterG_paused = false;
      counterG_active = true;
      Serial.println(F("Proceso G reanudado - Comando 'despausa' enviado"));
    } else {
      Serial1.println("pausa");
      pauseProcessG();
      Serial.println(F("Proceso G pausado - Comando 'pausa' enviado"));
    }
    needRedraw = true;
  }
  // BotÃ³n Regresar
  else if (y >= 195 && y <= 230 && x >= 60 && x <= 260) {
    Button btnRegresar = {60, 195, 200, 35, COLOR_DANGER, "REGRESAR", COLOR_LIGHT, 1};
    buttonPressEffect(btnRegresar);
    
    Serial.println(F("Regresando al menÃº de procesos"));
    currentScreen = SCREEN_PROCESS_MENU;
    needRedraw = true;
  }
}

void showCompletionMessage(bool isProcessP) {
  if (!screenOn) return;
  
  // AnimaciÃ³n de completado
  for (int i = 0; i <= 100; i += 5) {
    int width = i * 240 / 100;
    int height = i * 100 / 100;
    
    tft.fillRoundRect(160 - width/2, 120 - height/2, width, height, 10, COLOR_SUCCESS);
    delay(10);
  }
  
  tft.setTextColor(COLOR_BG);
  tft.setTextSize(1);
  tft.setCursor(120, 95);
  if (isProcessP) {
    tft.println(F("PROCESO P"));
  } else {
    tft.println(F("PROCESO G"));
  }
  tft.setCursor(110, 115);
  tft.println(F("COMPLETADO!"));
  tft.setCursor(60, 135);
  tft.println(F("Objetivo alcanzado exitosamente"));
  
  tft.setCursor(60, 155);
  tft.print(F("Total contado: "));
  tft.print(isProcessP ? counterP : counterG);
  
  delay(3000);
  
  // AnimaciÃ³n de desapariciÃ³n
  for (int i = 100; i >= 0; i -= 5) {
    int width = i * 240 / 100;
    int height = i * 100 / 100;
    
    tft.fillScreen(COLOR_BG);
    tft.fillRoundRect(160 - width/2, 120 - height/2, width, height, 10, COLOR_SUCCESS);
    delay(10);
  }
  
  drawProcessCounter(isProcessP);
}

void showTerminationMessage(bool isProcessP) {
  if (!screenOn) return;
  
  // AnimaciÃ³n de apariciÃ³n de notificaciÃ³n
  for (int i = 0; i <= 100; i += 5) {
    int width = i * 280 / 100;
    int height = i * 120 / 100;
    
    tft.fillRoundRect(160 - width/2, 120 - height/2, width, height, 10, COLOR_WARNING);
    delay(10);
  }
  
  // Borde de la notificaciÃ³n
  tft.drawRoundRect(38, 58, 244, 124, 10, COLOR_LIGHT);
  
  // Icono de terminaciÃ³n (cÃ­rculo con X)
  tft.drawCircle(160, 85, 15, COLOR_BG);
  tft.drawLine(150, 75, 170, 95, COLOR_BG);
  tft.drawLine(170, 75, 150, 95, COLOR_BG);
  
  tft.setTextColor(COLOR_BG);
  tft.setTextSize(1);
  tft.setCursor(110, 110);
  if (isProcessP) {
    tft.println(F("PROCESO P TERMINADO"));
  } else {
    tft.println(F("PROCESO G TERMINADO"));
  }
  tft.setCursor(80, 130);
  tft.println(F("Proceso finalizado externamente"));
  
  tft.setCursor(60, 150);
  tft.print(F("Contador actual: "));
  tft.print(isProcessP ? counterP : counterG);
  
  Serial.print(F("NotificaciÃ³n: Proceso "));
  Serial.print(isProcessP ? "P" : "G");
  Serial.println(F(" terminado externamente"));
  
  // Activar buzzer cuando se recibe comando "ter"
  activateBuzzer();
  
  // Esperar 7 segundos
  delay(7000);
  
  // AnimaciÃ³n de desapariciÃ³n
  for (int i = 100; i >= 0; i -= 5) {
    int width = i * 280 / 100;
    int height = i * 120 / 100;
    
    tft.fillScreen(COLOR_BG);
    tft.fillRoundRect(160 - width/2, 120 - height/2, width, height, 10, COLOR_WARNING);
    delay(10);
  }
  
  drawProcessCounter(isProcessP);
}

void startProcessP() {
  if (!modeSelectedP) return;
  
  counterP_active = true;
  counterP_paused = false;
  counterP = 0;
  EEPROM.put(0, counterP);
  EEPROM.commit();
  alertDismissed = false;
  Serial.print(F("Proceso P iniciado - Contador reseteado"));
  if (!infiniteP) {
    Serial.print(F(" con objetivo: "));
    Serial.println(targetP);
  } else {
    Serial.println(F(" en modo continuo"));
  }
}

void startProcessG() {
  if (!modeSelectedG) return;
  
  counterG_active = true;
  counterG_paused = false;
  counterG = 0;
  EEPROM.put(4, counterG);
  EEPROM.commit();
  alertDismissed = false;
  Serial.print(F("Proceso G iniciado - Contador reseteado"));
  if (!infiniteG) {
    Serial.print(F(" con objetivo: "));
    Serial.println(targetG);
  } else {
    Serial.println(F(" en modo continuo"));
  }
}

void pauseProcessP() {
  counterP_paused = true;
  counterP_active = false;
  Serial.println(F("Proceso P pausado"));
}

void pauseProcessG() {
  counterG_paused = true;
  counterG_active = false;
  Serial.println(F("Proceso G pausado"));
}

// Procesar comandos UART recibidos - UART1 para Pico RP2040
void processUARTCommands() {
  if (Serial1.available() > 0) {
    String cmd = Serial1.readStringUntil('\n');
    cmd.trim();
    
    if (cmd.length() > 0) {
      Serial.print(F("Comando recibido por UART1: "));
      Serial.println(cmd);
      
      // Procesar el comando para Proceso P
      if (currentScreen == SCREEN_PROCESS_P && counterP_active && !counterP_paused) {
        if (cmd == "contador") {
          counterP++;
          EEPROM.put(0, counterP);
          EEPROM.commit();
          Serial.print(F("Contador P incrementado: "));
          Serial.println(counterP);
          
          // Verificar si el contador llegÃ³ a 5 y activar buzzer
          if (counterP == 5) {
            activateBuzzer();
            Serial.println(F("Contador P llegÃ³ a 5 - Buzzer activado en GP20"));
          }
          
          if ((!infiniteP && counterP >= targetP) || (infiniteP && counterP >= HIDDEN_LIMIT)) {
            Serial.println(F("Â¡PROCESO P COMPLETADO!"));
            pauseProcessP();
            showCompletionMessage(true);
          } else {
            updateCounterDisplay(true);
          }
        } else if (cmd == "vacio") {
          // Activar buzzer cuando se recibe comando "vacio"
          activateBuzzer();
          drawBottleAlert();
        } else if (cmd == "ter") {
          showTerminationMessage(true);
        }
      }
      
      // Procesar el comando para Proceso G
      if (currentScreen == SCREEN_PROCESS_G && counterG_active && !counterG_paused) {
        if (cmd == "contador") {
          counterG++;
          EEPROM.put(4, counterG);
          EEPROM.commit();
          Serial.print(F("Contador G incrementado: "));
          Serial.println(counterG);
          
          // Verificar si el contador llegÃ³ a 5 y activar buzzer
          if (counterG == 5) {
            activateBuzzer();
            Serial.println(F("Contador G llegÃ³ a 5 - Buzzer activado en GP20"));
          }
          
          if ((!infiniteG && counterG >= targetG) || (infiniteG && counterG >= HIDDEN_LIMIT)) {
            Serial.println(F("Â¡PROCESO G COMPLETADO!"));
            pauseProcessG();
            showCompletionMessage(false);
          } else {
            updateCounterDisplay(false);
          }
        } else if (cmd == "vacio") {
          // Activar buzzer cuando se recibe comando "vacio"
          activateBuzzer();
          drawBottleAlert();
        } else if (cmd == "ter") {
          showTerminationMessage(false);
        }
      }
    }
  }
}

void updateCounterDisplay(bool isProcessP) {
  // Actualizar solo el valor del contador sin redibujar toda la pantalla
  tft.fillRect(170, 45, 100, 20, COLOR_DARK);
  
  tft.setTextSize(2);
  tft.setTextColor(COLOR_ACCENT);
  tft.setCursor(170, 45);
  tft.print(isProcessP ? counterP : counterG);
  
  // Actualizar informaciÃ³n de objetivo si es necesario
  if (!isProcessP ? !infiniteG : !infiniteP) {
    int target = isProcessP ? targetP : targetG;
    int counter = isProcessP ? counterP : counterG;
    
    tft.fillRect(30, 100, 250, 15, COLOR_DARK);
    tft.setTextSize(1);
    tft.setTextColor(COLOR_ACCENT);
    tft.setCursor(30, 100);
    tft.print(F("Objetivo: "));
    tft.print(target);
    tft.print(F(" (Faltan: "));
    tft.print(max(0, target - counter));
    tft.println(F(")"));
  }
  
  // AnimaciÃ³n de pulso para indicar incremento
  for (int i = 0; i < 3; i++) {
    tft.drawRoundRect(20, 35, 280, 50, 5, COLOR_ACCENT);
    delay(50);
    tft.drawRoundRect(20, 35, 280, 50, 5, COLOR_LIGHT);
    delay(50);
  }
}

void checkMenuTimeout() {
  if ((currentScreen == SCREEN_CONFIG_P || currentScreen == SCREEN_CONFIG_G) && menuTimeout > 0) {
    if (millis() - menuTimeout > timeoutDelay) {
      Serial.println(F("Timeout - Regresando al contador"));
      if (currentScreen == SCREEN_CONFIG_P) {
        currentScreen = SCREEN_PROCESS_P;
        needRedraw = true;
      } else {
        currentScreen = SCREEN_PROCESS_G;
        needRedraw = true;
      }
      menuTimeout = 0;
    }
  }
}

void updateAnimations() {
  if (millis() - lastAnimationTime < animationInterval) return;
  lastAnimationTime = millis();
  
  // Actualizar animaciones segÃºn la pantalla actual
  if (currentScreen == SCREEN_PROCESS_P || currentScreen == SCREEN_PROCESS_G) {
    bool isProcessP = (currentScreen == SCREEN_PROCESS_P);
    bool active = isProcessP ? counterP_active : counterG_active;
    bool paused = isProcessP ? counterP_paused : counterG_paused;
    bool modeSelected = isProcessP ? modeSelectedP : modeSelectedG;
    
    if (active && !paused && modeSelected) {
      // AnimaciÃ³n de pulso para el indicador de actividad
      static int pulseSize = 0;
      static bool growing = true;
      
      if (growing) {
        pulseSize++;
        if (pulseSize >= 5) growing = false;
      } else {
        pulseSize--;
        if (pulseSize <= 0) growing = true;
      }
      
      // Borrar el cÃ­rculo anterior
      tft.fillRect(240, 105, 20, 20, COLOR_DARK);
      // Dibujar el nuevo cÃ­rculo
      tft.fillCircle(250, 115, 5 + pulseSize, COLOR_SUCCESS);
    }
  }
}

void loop() {
  // Verificar si hay que redibujar la pantalla
  if (needRedraw) {
    switch (currentScreen) {
      case SCREEN_MAIN:
        drawMainMenu();
        break;
      case SCREEN_PROCESS_MENU:
        drawProcessMenu();
        break;
      case SCREEN_PROCESS_P:
        drawProcessCounter(true);
        break;
      case SCREEN_PROCESS_G:
        drawProcessCounter(false);
        break;
      case SCREEN_CONFIG_P:
        drawProcessConfig(true);
        break;
      case SCREEN_CONFIG_G:
        drawProcessConfig(false);
        break;
      case SCREEN_QUANTITY_P:
        drawQuantityMenu(true);
        break;
      case SCREEN_QUANTITY_G:
        drawQuantityMenu(false);
        break;
    }
    needRedraw = false;
  }
  
  checkTouch();
  processUARTCommands();
  checkMenuTimeout();
  updateAnimations();
}
