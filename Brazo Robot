#include "BluetoothSerial.h"
#include <ESP32Servo.h>

// Check if Bluetooth is enabled
#if !defined(CONFIG_BT_ENABLED) || !defined(CONFIG_BLUEDROID_ENABLED)
#error Bluetooth is not enabled! Please run `make menuconfig` to and enable it
#endif

BluetoothSerial SerialBT;

Servo servo01;
Servo servo02;
Servo servo03;
Servo servo04;
Servo servo05;
Servo servo06;

// Recommended safe GPIOs for ESP32 (avoiding pins 6-11)
const int servo1Pin = 13;
const int servo2Pin = 14;
const int servo3Pin = 25;
const int servo4Pin = 26;
const int servo5Pin = 27;
const int servo6Pin = 32;

int servo1PPos, servo2PPos, servo3PPos, servo4PPos, servo5PPos, servo6PPos; // previous position
int servo01SP[50], servo02SP[50], servo03SP[50], servo04SP[50], servo05SP[50], servo06SP[50]; // for storing positions/steps
int index = 0;
String dataIn = "";

void setup() {
  Serial.begin(115200);

  // Initialize Bluetooth with a name
  SerialBT.begin("BrazoRobot_ESP32");
  Serial.println("Bluetooth started. Connect to 'BrazoRobot_ESP32'");

  // Attach servos to pins
  servo01.attach(servo1Pin);
  servo02.attach(servo2Pin);
  servo03.attach(servo3Pin);
  servo04.attach(servo4Pin);
  servo05.attach(servo5Pin);
  servo06.attach(servo6Pin);
  
  // Robot arm initial position
  servo1PPos = 130; servo01.write(servo1PPos);
  servo2PPos = 180; servo02.write(servo2PPos);
  servo3PPos = 0;   servo03.write(servo3PPos);
  servo4PPos = 35;  servo04.write(servo4PPos);
  servo5PPos = 135; servo05.write(servo5PPos);
  servo6PPos = 45;  servo06.write(servo6PPos);
}

void loop() {
  if (SerialBT.available() > 0) {
    dataIn = SerialBT.readString();
    dataIn.trim();
    Serial.print("Datos recibidos: ");
    Serial.println(dataIn);

    // Manual movement
    if (dataIn.startsWith("s1")) moveServoManual(dataIn.substring(2).toInt(), servo01, servo1PPos);
    if (dataIn.startsWith("s2")) moveServoManual(dataIn.substring(2).toInt(), servo02, servo2PPos);
    if (dataIn.startsWith("s3")) moveServoManual(dataIn.substring(2).toInt(), servo03, servo3PPos);
    if (dataIn.startsWith("s4")) moveServoManual(dataIn.substring(2).toInt(), servo04, servo4PPos);
    if (dataIn.startsWith("s5")) moveServoManual(dataIn.substring(2).toInt(), servo05, servo5PPos);
    if (dataIn.startsWith("s6")) moveServoManual(dataIn.substring(2).toInt(), servo06, servo6PPos);

    if (dataIn.startsWith("SAVE")) savePositions();
    if (dataIn.startsWith("RUN")) runservo();
    if (dataIn == "RESET") resetPositions();
  }
}

// Fixed speed for manual control
void moveServoManual(int newPos, Servo &servo, int &prevPos) {
  if (newPos < 0 || newPos > 180) return;
  int distance = abs(newPos - prevPos);
  if (distance == 0) return;

  for (int j = 1; j <= distance; j++) {
    int curr = (prevPos < newPos) ? (prevPos + j) : (prevPos - j);
    servo.write(curr);
    delay(20);
  }
  prevPos = newPos;
}

// Timed movement for sequence playback (3 seconds)
void moveServoTimed(int newPos, Servo &servo, int &prevPos) {
  if (newPos < 0 || newPos > 180) return;
  int distance = abs(newPos - prevPos);
  if (distance == 0) return;

  int stepDelay = 3000 / distance; // Total 3s for the movement

  for (int j = 1; j <= distance; j++) {
    int curr = (prevPos < newPos) ? (prevPos + j) : (prevPos - j);
    servo.write(curr);
    delay(stepDelay);
  }
  prevPos = newPos;
}

void savePositions() {
  if (index < 50) {
    servo01SP[index] = servo1PPos;
    servo02SP[index] = servo2PPos;
    servo03SP[index] = servo3PPos;
    servo04SP[index] = servo4PPos;
    servo05SP[index] = servo5PPos;
    servo06SP[index] = servo6PPos;
    index++;
    Serial.println("Position saved at index: " + String(index - 1));
  } else {
    Serial.println("Memory full");
  }
}

void resetPositions() {
  index = 0;
  Serial.println("Positions reset");
}

void runservo() {
  if (index == 0) {
    Serial.println("No positions saved");
    return;
  }

  Serial.println("Running sequential timed sequence...");
  bool paused = false;

  while (!paused) {
    for (int i = 0; i < index; i++) {
      if (checkInterruption(paused)) break;
      moveServoTimed(servo01SP[i], servo01, servo1PPos);
      if (interruptibleWait(2000, paused)) break; // 2s wait before next servo

      if (checkInterruption(paused)) break;
      moveServoTimed(servo02SP[i], servo02, servo2PPos);
      if (interruptibleWait(2000, paused)) break;

      if (checkInterruption(paused)) break;
      moveServoTimed(servo03SP[i], servo03, servo3PPos);
      if (interruptibleWait(2000, paused)) break;

      if (checkInterruption(paused)) break;
      moveServoTimed(servo04SP[i], servo04, servo4PPos);
      if (interruptibleWait(2000, paused)) break;

      if (checkInterruption(paused)) break;
      moveServoTimed(servo05SP[i], servo05, servo5PPos);
      if (interruptibleWait(2000, paused)) break;

      if (checkInterruption(paused)) break;
      moveServoTimed(servo06SP[i], servo06, servo6PPos);
      if (interruptibleWait(2000, paused)) break;
    }
  }
  Serial.println("Sequence stopped/paused");
}

bool checkInterruption(bool &paused) {
  if (SerialBT.available() > 0) {
    dataIn = SerialBT.readString();
    dataIn.trim();
    if (dataIn == "PAUSE") {
      paused = true;
      return true;
    }
    if (dataIn == "RESET") {
      resetPositions();
      paused = true;
      return true;
    }
  }
  return false;
}

bool interruptibleWait(unsigned long duration, bool &paused) {
  unsigned long start = millis();
  while (millis() - start < duration) {
    if (checkInterruption(paused)) return true;
    delay(10);
  }
  return false;
}
